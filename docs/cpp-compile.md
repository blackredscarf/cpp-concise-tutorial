# C++ 编译

## 1. 编译运行
C++是静态语言，你需要将其经过编译和生成可执行文件才能运行。

C++有很多种编译器，比如gcc, clang, msvc等等。

以gcc为例，一个简单的编译C++源文件的命令如下：
```
g++ test.cpp -o test.o
```
编译后生成一个`test.o`的可执行文件（目标文件），可以直接执行。在Windows系统下，可以改为输出`test.exe`。

到 g++ 8.3.0 为止，g++的编译时使用的默认标准是C++11，如果你使用了更新标准的特性，需要手动指定其版本。
```
g++ test.cpp -o test.o -std=c++17
```

## 2. 单独编译
C++鼓励程序员将一些对象，通用函数放到独立的文件中，就是那些所谓的`.h`文件。而`.h`文件只是定义，不负责实现。事实上，如果你在学习C++之前，学习过python或java等面向对象语言，你可能会疑惑，为什么要有头文件呢？

关于这一点是有多种原因的，
1. C语言比较落后，若不用头文件，便要用额外内存把接口信息存储到元数据(meta data)中，Java等后来出现的语言就是这么干的。虽然C++已经很现代，但仍然沿用了头文件的设计。
2. 避免环形调用。比如A文件调用B文件的方法，B文件又去调用A文件的方法，在python里面就不能这么干。
3. 为了能够**减少编译**。C++编译器既编译程序，也**管理链接器**。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。

大多数C++环境都提供了其他工具来帮助管理。例如，UNIX和Linux系统都具有make程序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序所需的步骤。

### 2.1 例子
构建一个`coordin.h`文件。其中`#ifndef`和`#endif`是为了使得一个头文件被导入多个文件后，在编译时不会被多次编译，为这个作用域赋予了`COORDIN_H_`的名称。
```cpp
#ifndef COORDIN_H_ 

#define COORDIN H

struct polar {
    double angle;
};

struct  rect {
    double x;
};

polar rec_to_polar(rect xypos);
void show_polar(polar dapos);

#endif
```

那么当多个文件是如何使用`coordin.h`的呢？

![](https://i.loli.net/2019/03/15/5c8b8aa0e2bbc.png)


从图上我们可以看出，我们在file2.cpp中将头文件中的两个方法实现了，而file1.cpp可以通过头文件将其调用，这就是上面所说的**链接**。

值得注意的是，我们使用`coordin.h`，而不是`<coodin.h>`。如果文件名包含在**尖括号**中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在**双引号**中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）。

