# C++ 编译

## 1. 编译运行
C++是静态语言，你需要将其经过编译和生成可执行文件才能运行。

C++有很多种编译器，比如gcc, g++, clang, msvc等等。gcc会分别区分c和cpp文件来编译，而g++则统一当作cpp文件来编译。

以g++为例，一个简单的编译C++源文件的命令如下：
```
g++ test.cpp -o test.o
```
编译后生成一个`test.o`的目标文件，如果目标文件包含main函数则可以直接执行。在Windows系统下，可以改为输出`test.exe`。

到 g++ 8.3.0 为止，g++的编译时使用的默认标准是C++11，如果你使用了更新标准的特性，需要手动指定其版本。
```
g++ test.cpp -o test.o -std=c++17
```

## 2. 单独编译
C++鼓励程序员将一些对象，通用函数放到独立的文件中，就是那些所谓的`.h`文件。而`.h`文件只是定义，不负责实现。事实上，如果你在学习C++之前，学习过python或java等面向对象语言，你可能会疑惑，为什么要有头文件呢？

关于这一点是有多种原因的，
1. C语言比较落后，若不用头文件，便要用额外内存把接口信息存储到元数据(meta data)中，Java等后来出现的语言就是这么干的。虽然C++已经很现代，但仍然沿用了头文件的设计。
2. 避免环形调用。比如A文件调用B文件的方法，B文件又去调用A文件的方法，在python里面就不能这么干。
3. 为了能够**减少编译**。C++编译器既编译程序，也**管理链接器**。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。

大多数C++环境都提供了其他工具来帮助管理。例如，UNIX和Linux系统都具有make程序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序所需的步骤。

### 2.1 编译过程
构建一个`coordin.h`文件。其中`#ifndef`和`#endif`是为了使得一个头文件被导入多个头文件后，在编译时不会被多次编译，为这个作用域赋予了`COORDIN_H_`的名称。在头文件顶部加上`#pragma once`则可以防止整个文件被重复导入。
```cpp
#ifndef COORDIN_H_ 

#define COORDIN_H_

struct polar {
    double angle;
};

struct  rect {
    double x;
};

polar rec_to_polar(rect xypos);
void show_polar(polar dapos);

#endif
```

那么当多个文件是如何使用`coordin.h`的呢？

![](https://i.loli.net/2019/03/15/5c8b8aa0e2bbc.png)

从编译命令可以看出，我们指定的是`.cpp`源文件，而非`.h`头文件，意味着编译是针对源文件里编译，而且每个源文件是单独编译的，编译过程主要为：

1. 预处理阶段：这个阶段主要分析宏指令，包括解析`#define`, `#include`等，每个源文件都是单独处理的。以`#include`为例，对于每个源文件，直接把头文件里面的声明和定义插入到源代码中。
2. 编译阶段：这个阶段主要把源代码进行编译，即词法分析、语法分析、中间代码生成，最终生成每个cpp对应的`.s`汇编文件。
3. 汇编阶段：机器码生成，把`.s`文件中的汇编语言转换为机器语言，最后生成的是每个cpp对应的`.o`目标文件。
4. 链接阶段：上一阶段每个源文件会生成一个与之对应的`.o`文件，即目标文件，链接则是把所有目标代码文件合成一个可执行文件。因为一个源文件调用的函数的定义可能包含在另一个源文件里，所以需要把函数链接至正确的地址。

从图上我们可以看出，file1.cpp通过头文件`coordin.h`只知道声明而不知道方法的具体定义就可以通过编译阶段了，我们在file2.cpp中将头文件中的两个方法实现了，只要在链接阶段，file1.cpp正确找到到两个方法的定义即可，这就是上面所说的**链接**。

值得注意的是，我们使用`coordin.h`，而不是`<coodin.h>`。如果文件名包含在**尖括号**中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在**双引号**中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）。

### 2.2 头文件的重复导入
前面我们提到，在头文件写上`#ifndef`和`#endif`是为了使得一个头文件被多个头文件所导入后，不会发生重复定义问题，但这么做只能限制头文件之间的导入，而无法防止头文件同时被多个源文件导入的情况。正如上面的过程里讲到，对于宏的解析，只是在预处理阶段，而真正查找具体定义是在链接阶段。如果你的头文件只包含声明而不包含定义，自然没有问题，因为C++允许重复声明，如果头文件里面包含了定义则会导致**重复定义**问题，因为在链接过程中会发现不同目标文件里存在多个定义，链接器不知道该链接至哪个定义。

重复定义不只是针对重复导入的问题，而是同一个声明在不同源文件中有不同的定义也是重复定义问题。

在头文件里面的定义而不会发生重复定义问题的有以下几种情况，

（1）对于static的变量和函数，不会发生重复定义问题，static具有只定义一次的特性，目前还未清楚编译器是如何处理的，但经过测试可知不会发生重复定义问题。

（2）inline函数，inline函数必须在头文件里定义，它在预处理阶段会进行代码替换，并非真正的函数，不会发生重复定义问题。

（3）对于头文件里面的类，类定义不会有重复定义问题，类中可以带有对函数的定义实现，内部实现被视为inline函数。

（4）模板函数，它和宏一样是通过代码生成实现的，实际上也是在预处理阶段就生成好的。进一步的说，模板函数必须在头文件里面定义好，因为定义的链接发生在预处理阶段之后，如果不在头文件里面定义好，预处理阶段时根本不知道你的定义在哪里，自然也无法帮你生成函数实现了，进而无法产生链接，在链接阶段会报未定义错误。

## 3. 库
我们一般把没有main函数的目标文件称为库，所谓的库你可以理解为若干目标文件的集合，其中仅包含变量、函数或类的定义。其实我们的程序可以以3种形式编译：

1. 把所有源文件和main函数文件打包到一个可执行文件里
2. 把部分源文件打包成共享库，然后编译可执行文件时指定共享库的位置，最终生成的可执行文件不包含共享库，只是一个引用了共享库的定义而已。从操作系统层面去理解的话，共享库代码段会以共享虚拟内存页面的方式映射到各个进程虚拟地址空间里，进程对共享库的访问实际上是对共享内存的访问
3. 把部分源文件打包成静态库，然后编译可执行文件时指定静态库的位置，最终生成的可执行文件会把静态库一起打包到可执行文件里

三种方式各有各的好处，

1. 一次性打包所有源文件。这是比较干脆的方式，一般用在整个项目都是一体的情况下，不需要单独提供接口给其他项目使用。
2. 共享库。基础模块会被很多进程使用，则基础模块可以作为共享库，这样可能节省重复代码段占用的内存，可执行文件的大小也会小一点。
3. 静态库。静态库其实就是提供一个不需要暴露源代码的目标文件，如果你写了一个库又不想开源，则可以考虑向他人提供目标文件和头文件即可。

### 3.1 统一打包
假设我们的项目有main.cpp, test.h, test.cpp，在main.cpp里调用test.h声明的接口。
```cpp
// main.cpp
#include <iostream>
#include "test.h"

int main() {
    output();
    return 0;
}
```
```cpp
// test.h
#pragma once

void output();
```
```cpp
// test.cpp
#include <iostream>
#include "test.h"

void output() {
    std::cout << "output" << std::endl;
}
```

先演示第一种情况，把所有源文件都打包到一个可执行文件里，
```
g++ main.cpp test.cpp -o main1.exe
```
执行测试，
```
> main1.exe
output
```

### 3.2 共享库
指定`-shared`生成共享目标文件，不同系统的库的命名规范不同，linux是`libXX.so`，而windows则是`XX.dll`，
```shell
# linux
g++ test.cpp -shared -o libtest.so

# windows
g++ test.cpp -shared -o test.dll
```
编译可执行文件，链接共享库，
```
g++ -ltest -L. main.cpp -o main2.exe
```
- `-l`表示要链接的库名称，指定时可省略空格
- `-L`表示库所在的路径

指定了`-L`会导致可执行文件查找共享库的位置写死，如果指定路径下没有对应的共享库，程序会出错，比如有些软件会要求把dll和exe放在同一目录下，就是这个原因。对于常用库文件，一般我们不指定`-L`，而是放在系统目录，编译器会自动从系统目录里查找。linux的目录为/usr/lib，也可以通过LD_LIBRARY_PATH环境变量指定共享库目录。windows的目录为C:\Windows\system32，可以在PATH环境变量自定义目录。

### 3.3 静态库
g++默认情况下会直接生成可执行文件，如果我们只需要编译一个库而已，则不需要main函数，也不需要马上去链接静态库本身的依赖库的定义，我们不会直接运行一个库，依赖库的定义并不关心，实际上链接是在最后打包成可执行文件时才需要做的，现在只需要把自己的定义打包到一个目标文件里。

g++命令带上`-c`参数，不进行最后的链接阶段，生成目标文件，
```
g++ -c test.cpp -o test.o
```
把若干目标文件打包到静态库文件`libXXX.a`里，`.a`文件没有那么神秘，你可以理解为一个压缩文件，ar命令相当于tar，
```
ar -rc libtest.a test.o
```
打包可执行文件时导入静态库，
```
g++ main.cpp -ltest -L. -static -o main3.exe
```
- `-l`表示要链接的库名称，默认省略掉前面的`lib`
- `-L`表示库所在的路径
- `-static`表示以静态库方式链接

### 3.4 运行时动态链接
一般共享库都是加载时动态链接，即程序开始前找到动态库信息。而共享库的另一个别称是动态库，它支持程序运行时进行动态链接。这部分的API没有做到跨平台，windows和linux用的是不同的API。windows的API在windows.h上，而linux的API在dlfcn.h。

如果你想用C++实现代码热更新，可以用动态链接的方式，每次更新只要把动态库替换的就可以了，但意味着每次函数的调用需要通过字符串从dll里面获取具体函数地址，然后再调用。






